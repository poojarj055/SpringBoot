Spring Data JPA provides various ways to interact with your database through the repository pattern. It simplifies data access by providing a set of well-defined methods to perform CRUD operations, as well as more complex queries. Here’s a breakdown of the types of queries you can use, along with pagination and other related topics.

### 1. **Derived Query Methods**
Derived query methods are automatically generated by Spring Data JPA based on the method name. These methods follow a specific naming convention, allowing you to create queries without writing explicit JPQL or SQL.

#### **Examples:**
```java
// Find by single property
List<User> findByFirstName(String firstName);

// Find by multiple properties
List<User> findByLastNameAndFirstName(String lastName, String firstName);

// Find by a property and order the results
List<User> findByLastNameOrderByFirstNameAsc(String lastName);

// Find top N records
User findTopByOrderByAgeDesc();
```

### 2. **JPQL (Java Persistence Query Language) Queries**
JPQL is similar to SQL, but it works with JPA entities rather than database tables. It’s used for more complex queries that cannot be easily expressed using derived query methods.

#### **Examples:**
```java
@Query("SELECT u FROM User u WHERE u.email = :email")
User findUserByEmail(@Param("email") String email);

@Query("SELECT u FROM User u WHERE u.age > :age ORDER BY u.firstName DESC")
List<User> findUsersOlderThan(@Param("age") int age);
```

### 3. **Native SQL Queries**
Native SQL queries allow you to write raw SQL queries. These are useful when JPQL doesn’t support certain database-specific features or optimizations.

#### **Examples:**
```java
@Query(value = "SELECT * FROM users u WHERE u.status = ?1", nativeQuery = true)
List<User> findUsersByStatus(String status);

@Query(value = "SELECT * FROM users u WHERE u.age > :age", nativeQuery = true)
List<User> findUsersOlderThan(@Param("age") int age);
```

### 4. **Named Queries**
Named queries are defined in the JPA entity class or in an XML mapping file. They are predefined and can be reused in different parts of your application.

#### **Examples:**
```java
@Entity
@NamedQuery(name = "User.findByStatus", query = "SELECT u FROM User u WHERE u.status = :status")
public class User {
    // entity fields and methods
}

// Usage
List<User> users = userRepository.findByStatus("ACTIVE");
```

### 5. **@Modifying Queries**
The `@Modifying` annotation is used for update and delete operations in JPQL or native queries. These queries are not supposed to return any entities, just an integer indicating the number of rows affected.

#### **Examples:**
```java
@Modifying
@Query("UPDATE User u SET u.status = :status WHERE u.id = :id")
int updateUserStatus(@Param("id") Long id, @Param("status") String status);

@Modifying
@Query("DELETE FROM User u WHERE u.id = :id")
void deleteUserById(@Param("id") Long id);
```

### 6. **Pagination and Sorting**
Spring Data JPA provides built-in support for pagination and sorting via the `Pageable` and `Sort` interfaces. Pagination is useful when you want to retrieve data in chunks rather than loading all records at once.

#### **Examples:**
```java
// Pagination
Page<User> findByLastName(String lastName, Pageable pageable);

// Sorting
List<User> findByLastName(String lastName, Sort sort);

// Pagination with sorting
Page<User> findByLastName(String lastName, Pageable pageable);

// Usage
Pageable pageable = PageRequest.of(0, 10, Sort.by("firstName").ascending());
Page<User> usersPage = userRepository.findByLastName("Smith", pageable);

// Accessing pagination info
int totalPages = usersPage.getTotalPages();
long totalItems = usersPage.getTotalElements();
List<User> users = usersPage.getContent();
```

### 7. **Specification Queries**
Specification queries allow for the creation of dynamic and complex queries. They are particularly useful when you need to build queries based on various criteria at runtime.

#### **Examples:**
```java
public class UserSpecification implements Specification<User> {

    public static Specification<User> hasFirstName(String firstName) {
        return (root, query, criteriaBuilder) ->
            criteriaBuilder.equal(root.get("firstName"), firstName);
    }

    public static Specification<User> hasLastName(String lastName) {
        return (root, query, criteriaBuilder) ->
            criteriaBuilder.equal(root.get("lastName"), lastName);
    }
}

// Usage
Specification<User> spec = UserSpecification.hasFirstName("John")
                              .and(UserSpecification.hasLastName("Doe"));
List<User> users = userRepository.findAll(spec);
```

### 8. **Query by Example (QBE)**
Query by Example is a technique to search for entities by providing an example of the entity with the desired properties set. Spring Data JPA can then find matching entities based on the example.

#### **Examples:**
```java
// Example entity
User probe = new User();
probe.setFirstName("John");

// Query by Example
Example<User> example = Example.of(probe);
List<User> users = userRepository.findAll(example);
```

### Summary
- **Derived Query Methods**: Simple queries generated from method names.
- **JPQL Queries**: More complex queries based on entity models.
- **Native SQL Queries**: Direct use of raw SQL.
- **Named Queries**: Predefined queries tied to an entity.
- **@Modifying Queries**: For update or delete operations.
- **Pagination and Sorting**: Retrieve data in pages with sorting.
- **Specification Queries**: Dynamic query construction.
- **Query by Example (QBE)**: Find entities based on an example entity.

Each of these methods offers a different level of flexibility and complexity, allowing you to choose the one that best fits your use case.
